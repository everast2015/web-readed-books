# 《javascript 权威指南》

## 对象

创建对象的几种方式：
1. 对象直接量
2. 关键字new
3. `ES5`的`Object.create()` 函数

- 对象直接量

创建对象直接量最简单的方法就是使用一个花括号进行创建。
```js
var empty = {}; // 创建一个空的对象
```

对象直接量是由若干名/值对组成的映射表，名/值对中间用冒号隔开，整个映射表用花括号括起来。

- 通过 `new` 创建对象。

```js
var object = new Object();

```

这里的函数称为构造函数`constructor`，构造函数用以初始化一个新创建的对象。

- `Object.create()` 

`ES5` 定义了一个名为`Object.create()` 的方法，它创建了一个新对象，其中第一个参数是这个对象的原型，第二个可选参数，用以对对象的属性进行进一步的描述。

```js
var o1 = Object.create({
    x:1,
    y:1
});
```

### 属性的设置和查询
在`js` 中可以通过点`(.)`或方括号`[]` 运算符来获取对象的属性的值。
获取属性的值：
```js
var author = book.author;
var title = book['main title'];
```
设置属性的值：
```js
book.author = "you name";
book['main title'] = "ECMASCRIPT";
```

### 删除属性
`delete` 运算符可以删除对象的属性。
```js
delete book.author; // book 不再有属性 author
delete book["main title"]
```
`delete` 运算符只能删除自有属性，不能删除继承属性（要删除继承属性必须是从定义这个属性的原型对象是哪个删除它，而已这会影响到所有继承自这个原型的对象）。

### 检查属性
判断某个属性是否存在与对象中，可以通过`in` 运算符、`hasOwnPreperty()` 和 `propertyIsEnumerable()` 方法来完成这个工作。

```js
var o = {x: 1}
o.hasOwnProperty("x"); // true 0有一个自有属性x
o.hasOwnproperty("y"); // false o 不存在自有属性 y
```
![对象](https://github.com/yjn2015/web-readed-books/blob/master/js-anthoritative/object.png)
## 作用域

作用域指一个变量的作用的范围

在`js` 中一共有两种作用域：

### 1. 全局作用域
- 直接写在`<script></script>` 标签中的`JS`代码，都在全局作用域。
- 全局作用域在页面打开时创建，在页面关闭时销毁。
- 在全局作用域中有一个全局对象`window`
> 它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用

- 在全局作用域中

1. 创建的变量都会作为`window`的属性保存起来
2. 创建的函数都将作为`window`对象的方法保存起来。

- 全局作用域中的变量都是全局变量
> 在页面中的任何地方都是可以访问的到的

### 变量的声明提前

> 使用`var`关键字声明的变量，会在所有代码执行之前被声明（但是不会赋值），但是如果声明变量时不使用`var`关键字，则变量不会被声明提前

```js
console.log("a= " + a);
a = 123;
```

![报错](https://github.com/yjn2015/web-readed-books/blob/master/js-anthoritative/img/a.png)

### 使用函数声明提前

- 使用函数声明形式创建的函数`function 函数(){}`
1. 它会在所有的代码执行之前被创建，所以我们可以在函数声明前来调用函数
2. 使用函数表达式声明的变量，不会被声明提前，所以不能在声明前调用


```js
func2();

// 函数声明会被声明提前
function func2() {
    console.log("我是func2函数");
}

var func3 = function func3() {
    console.log("我是func3函数");
}
```

### 2. 函数作用域
1. 调用函数时创建函数作用域，函数执行完毕之后，函数作用域销毁
2. 每调用一次函数就会创建一个新的作用域，他们之间是相互独立的

```js
function func() {

}

func();
func();
func()
```

## 数组

创建数组的方式：
1. 利用`new` 创建数组
```js
var arr  = new Array();
```
2. 利用数组字面量创建一个数组

```js

var arr = [];
```

获取数组的方式：

格式：数组名[索引号]
索引[下标]用来访问数组元素的序号，（数组下标从0开始）

数组可以通过索引来访问，设置，修改对应的数组元素，我们可以通过“数组名[索引]”的形式来获取数组中的元素。

这里的访问就是获取得到的意思。

获取数组的长度：使用的是关键词`length`属性

`arr.length`是动态获取数组的长度：

## 函数

函数就是包裹在花括号中的代码块

2. 我们可以利用函数的不同的参数，实现不同的参数代码

```js
// 在声明函数的小括号中调用的参数是形参（形式上的参数）
function 函数名(形参1，形参2) {
 console.log(形参1，形参2);
}

// 在函数调用的小括号里面是实参（实际上的参数）
函数名(实参1，实参2)
```
形参是接受实参的，形参相当于一个变量，而实参表示的是真正传递的参数。

函数的参数可以有，也可以一个也没有

## 实参和形参的区别

在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在函数调用时，t同样也需要传递相应的参数，这些参数被称为实参。

参数 | 说明 |
-----| ----|
形参 | 形式上的参数，函数定义的时候 传递的参数 当时并不知道是什么
实参 | 实际上的参数，函数调用的时候传递的参数，实参是传递给形参的

参数的作用：在参数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。

1. 函数形参实参个数匹配
```js
function getSum(num1,num2) {
    console.log(num1 + num2)
}

// 1. 如果实参的个数和形参的个数一致 则正常输出结果
getSum(1,2)

// 2. 如果实参的个数多余形参的个数，会取到形参的个数
getSum(1,2,3);

// 3. 如果实参的个数小于形参的个数，多余的形参定义为undefined,最终的结果就是NaN
// 形参可以看做是不用声明的变量，num2是一个变量但是没有接受值，结果就是undefined

getSum(1); // NaN

// 建议，我们最终方案是让形参和实参的个数匹配
```
函数形参和实参个数不匹配问题

参数个数 | 说明
---------| ---- |
实参个数等于形参个数 | 输出正确结果
实参个数多余形参个数 | 只取形参的个数
实参个数小于形参个数 | 多的形参定义为undefined，结果是NaN

注意，在`Javascript` 中形参默认值为`undefined`

## 函数的返回值

1. return 语句
